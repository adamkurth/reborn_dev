from __future__ import division

import sys
from time import time

import numpy as np
np.seterr(divide='ignore', invalid='ignore') # We expect a divide-by-zero, which is corrected... I don't like the annoying message...
from scipy.stats import binned_statistic_dd
from scipy.spatial import distance, cKDTree
import matplotlib.pyplot as plt
import matplotlib as mpl
from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection

sys.path.append("../..")
import bornagain as ba
from bornagain.units import hc, keV
from bornagain.simulate.clcore import ClCore
import pyqtgraph.opengl as gl
import pyqtgraph as pg

# Viewing choices
qtview = True

# How many diffraction patterns to simulate
n_patterns = 1000

# Intensity of the fluoress
add_noise = True
photons_per_atom = 1000

# whether to use Henke or Cromer mann
use_henke = True  # if False, then use Cromer-mann version

# Information about the object
n_molecules = 10
box_size = 10e-9
do_rotations = False
do_phases = True
do_translations = True

# Information about the emission
photon_energy = 6.5 / keV
wavelength = hc / photon_energy
beam_vec = np.array([0, 0, 1.0]) # This shouldn't matter...

# Single molecule atomic positions:
r = np.array([[0, 0, 0],
              [5e-10, 0, 0]])
r -= r.mean(0)  # mean sub, I dunno it matters or not , but for rotations maybe...

# Settings for pixel-array detector
n_pixels = 100
pixel_size = 0.0005
detector_distance = .05

# Settings for spherical detector
spherical_detector = True
n_subdivisions = 3
radius = 1


print('Will simulate %d patterns' % (n_patterns))

# TODO: move this to detector?

class IcosphereGeometry():
    """
    Experimental class for a spherical detector that follows the "icosphere" geometry.
    The Icosphere is generated by sub-dividing the vertices of an icosahedron.
    The following blog was helpful:
    http://sinestesia.co/blog/tutorials/python-icospheres/
    The code is quite slow; needs to be vectorized with numpy...
    """

    n_subdivisions = 1
    radius = 1

    def __init__(self, n_subdivisions=1, radius=1):

        self.n_subdivisions = n_subdivisions
        self.radius = radius

    def _vertex(self, x, y, z):
        """ Return vertex coordinates fixed to the unit sphere """

        length = np.sqrt(x ** 2 + y ** 2 + z ** 2)

        return [(i * self.radius) / length for i in (x, y, z)]

    def _middle_point(self, point_1, point_2, verts, middle_point_cache):
        """ Find a middle point and project to the unit sphere """

        # We check if we have already cut this edge first
        # to avoid duplicated verts
        smaller_index = min(point_1, point_2)
        greater_index = max(point_1, point_2)

        key = '{0}-{1}'.format(smaller_index, greater_index)

        if key in middle_point_cache:
            return middle_point_cache[key]

        # If it's not in cache, then we can cut it
        vert_1 = verts[point_1]
        vert_2 = verts[point_2]
        middle = [sum(i) / 2 for i in zip(vert_1, vert_2)]

        verts.append(self._vertex(*middle))

        index = len(verts) - 1
        middle_point_cache[key] = index

        return index

    def compute_vertices_and_faces(self):

        # Make the base icosahedron

        vertex = self._vertex
        middle_point = self._middle_point
        middle_point_cache = {}

        # Golden ratio
        PHI = (1 + np.sqrt(5)) / 2

        verts = [
            vertex(-1, PHI, 0),
            vertex(1, PHI, 0),
            vertex(-1, -PHI, 0),
            vertex(1, -PHI, 0),

            vertex(0, -1, PHI),
            vertex(0, 1, PHI),
            vertex(0, -1, -PHI),
            vertex(0, 1, -PHI),

            vertex(PHI, 0, -1),
            vertex(PHI, 0, 1),
            vertex(-PHI, 0, -1),
            vertex(-PHI, 0, 1),
        ]

        faces = [
            # 5 faces around point 0
            [0, 11, 5],
            [0, 5, 1],
            [0, 1, 7],
            [0, 7, 10],
            [0, 10, 11],

            # Adjacent faces
            [1, 5, 9],
            [5, 11, 4],
            [11, 10, 2],
            [10, 7, 6],
            [7, 1, 8],

            # 5 faces around 3
            [3, 9, 4],
            [3, 4, 2],
            [3, 2, 6],
            [3, 6, 8],
            [3, 8, 9],

            # Adjacent faces
            [4, 9, 5],
            [2, 4, 11],
            [6, 2, 10],
            [8, 6, 7],
            [9, 8, 1],
        ]

        # -----------------------------------------------------------------------------
        # Subdivisions

        for i in range(self.n_subdivisions):
            faces_subdiv = []

            for tri in faces:
                v1 = middle_point(tri[0], tri[1], verts, middle_point_cache)
                v2 = middle_point(tri[1], tri[2], verts, middle_point_cache)
                v3 = middle_point(tri[2], tri[0], verts, middle_point_cache)

                faces_subdiv.append([tri[0], v1, v3])
                faces_subdiv.append([tri[1], v2, v1])
                faces_subdiv.append([tri[2], v3, v2])
                faces_subdiv.append([v1, v2, v3])

            faces = faces_subdiv

        faces = np.array(faces)
        verts = np.array(verts)
        n_faces = faces.shape[0]

        face_centers = np.zeros([n_faces, 3])
        for i in range(0, n_faces):
            face_centers[i, :] = (verts[faces[i, 0], :] + verts[faces[i, 1], :] + verts[faces[i, 2], :]) / 3

        return verts, faces, face_centers


###########
# TODO: move this into e.g. target
#############

class Place(cKDTree):
    def __init__(self, box_edge, min_dist, max_try=10000, *args, **kwargs):
        """
        Place points into a box of edge length box_edge, and don't let any two points
        
        Parameters
        ==========
        get with    t0 = time()in min_dist from one another.

        box_edge, float
            side length of the box to place spheres into
        min_dist, float
            minimum distance between two points in the box
        max_try, int
            number of times to try placing a new point such 
            that is does not overlap
        
        """
        np.random.seed()
        a = np.random.uniform(0, box_edge, (1, 3))
        cKDTree.__init__(self, a, *args, **kwargs)
        self.min_dist = min_dist
        self.box_edge = box_edge
        self.max_try = max_try
        self.too_dense = False

    def insert(self):
        """adds a new point to the box"""
        new_pt = np.random.uniform(0, self.box_edge, (1, 3))
        n_try = 0
        # @dermen - why is the inequality comparing with inf?
        is_overlapping = self.query(new_pt, distance_upper_bound=self.min_dist)[
                             0] < np.inf  # query for a nearest neighbor
        while is_overlapping:
            new_pt = np.random.uniform(0, self.box_edge, (1, 3))
            is_overlapping = self.query(new_pt, distance_upper_bound=self.min_dist)[0] < np.inf
            n_try += 1
            if n_try > self.max_try:
                print("Getting too tight in here!")
                self.too_dense = True
                return
        data = np.concatenate((self.data, new_pt))  # combine new pt and old pts
        super(Place, self).__init__(data)  # re-initialize the parent class with new data




# def place_spheres(Vf, sph_rad=1., box_edge=None, Nspheres=1000, tol=0.01):
#     """
#     Vf, float
#         Fraction of sample volume occupied by spheres
#     Nspheres, int
#         how many spheres in the sample volume
#     tol, float
#         minimum distance the unit spheres can be to one another
#     """
#     #   volume of a unit sphere
#     sph_vol = (4 / 3.) * np.pi * (sph_rad) ** 3
#
#     if box_edge is not None:
#         #       then we let Nspheres be a free
#         box_vol = box_edge ** 3
#         Nspheres = int((box_vol * Vf) / sph_vol)
#     else:
#         #       then Nspheres determines the size of the box
#         box_vol = sph_vol * Nspheres / Vf
#         box_edge = np.power(box_vol, 1 / 3.)
#
#     min_dist = 2 * sph_rad + tol  # diameter plus tol,
#
#     print("Placing %d spheres into a box of side length %.4f" % (Nspheres, box_edge))
#
#     p = Place(box_edge, min_dist)  # init the Placer
#     while p.n < Nspheres:
#         p.insert()  # insert pt!
#         if p.too_dense:
#             print("\tbreaking insert loop with %d/%d spheres" % (p.n, Nspheres))
#             break
#
#     return p.data


###########
# END COPY/PASTE
###########


# maximum distance spanned by the molecule:
r_size = distance.pdist(r).max()
n_atoms = r.shape[0]

if spherical_detector:
    print('Creating spherical detector...')
    ico = IcosphereGeometry(n_subdivisions=n_subdivisions, radius=radius)
    verts, faces, fcs = ico.compute_vertices_and_faces()
    n_faces = faces.shape[0]
    q = (2 * np.pi / wavelength) * (fcs - beam_vec)
    print('%d pixels' % (q.shape[0]))
else:
    pad = ba.detector.PADGeometry()
    pad.simple_setup(n_pixels=n_pixels, pixel_size=pixel_size, distance=detector_distance)
    q = pad.q_vecs(beam_vec=beam_vec, wavelength=wavelength)

n_q = q.shape[0]

# # Place molecules in a 10 nm box
# dimer_placer = Place(box_edge=10e-9, min_dist=r_size)
# for i in range(n_molecules):
#     dimer_placer.insert()
# dimer_pos = dimer_placer.data

print('Simulating intensities...')
I_avg = 0
II = 0
clcore = ClCore(group_size=1)
q_dev = clcore.to_device(q)
seconds = 0
t0 = time()
for pattern_num in range(0, n_patterns):

    if use_henke:

        # Random phases for each atom
        if do_phases:
            phases = np.random.random(n_atoms * n_molecules) * 2 * np.pi
        else:
            phases = np.zeros([n_atoms * n_molecules])
        fs = np.exp(1j * phases)

        # Random positions for each molecule
        if do_translations:
            Ts = np.random.random([n_molecules, 3])*box_size
        else:
            Ts = np.zeros([n_molecules, 3])

        # Randomly rotate and translate the molecules
        rs = []
        for n in range(0, n_molecules):
            if do_rotations:
                R = ba.utils.random_rotation()
            else:
                R = np.eye(3)
            T = Ts[n, :]
            rs.append(np.dot(R, r.T).T + T)
        rs = np.array(rs).reshape([n_molecules*n_atoms, 3])  # miliseconds slow down

        # Compute intensities
        A = clcore.phase_factor_qrf(q_dev, rs, fs)
        I = np.abs(A) ** 2

        dt = time()-t0
        # print(time(), t0, np.floor(dt), seconds)
        if np.floor(dt) > seconds:
            seconds = np.floor(dt)
            print('Pattern %6d of %6d ; %3.0f%% ; %3.3g patterns/second' % (pattern_num, n_patterns, 100*pattern_num/float(n_patterns), pattern_num/dt))

    else:  # use cromer/mann
        ##### alternatively, using this old code i wrote we dont have to make copies of molecule
        # init CLCORE
        clcore = ClCore(group_size=1)
        clcore.prime_cromermann_simulator(q, np.array([79., 79.]))  # put in two bogus atomic numbers for Carbon
        qcm = clcore.get_q_cromermann()
        rcm = clcore.get_r_cromermann(r, sub_com=1)  # takes atom positions of single molecule
        for n in range(n_molecules):
            #   make the random phases, pass to run_crommer_mann function
            phases = np.random.random(n_atoms) * 2 * np.pi
            #   run cromermann
            clcore.run_cromermann(qcm, rcm, rand_rot=True, com=dimer_pos[n], rand_phase=phases)
        A = clcore.release_amplitudes()
        I = np.abs(A) ** 2

    I *= photons_per_atom * n_atoms * n_molecules / np.sum(I.ravel())
    if add_noise: I = np.random.poisson(I)

    I_avg += I
    I = I.astype(np.float32)
    II += np.multiply.outer(I, I).ravel()

print('Post-processing...')

n_q = q.shape[0]
qq = [np.subtract.outer(fcs[:, i], fcs[:, i]).ravel() for i in range(0, 3)]
qq = 2*np.pi/wavelength*np.ravel(qq).reshape([3, n_q**2]).T.copy()
# print(qq.shape)
# for i in range(0,n_q):
#     for j in range(0,n_q):
#         qq[i,j,:] = 2*np.pi/wavelength * (fcs[i,:] - fcs[j,:])
q_mags = np.sqrt(np.sum(q**2, axis=1))
max_q = 4*np.pi/wavelength

n_bins_3d = 55
III, _, _ = binned_statistic_dd(sample=qq, values=II, bins=(n_bins_3d,)*3, range=[(-max_q, max_q)]*3, statistic='sum')
IIIc, _, _ = binned_statistic_dd(sample=qq, values=np.ones(II.shape), bins=(n_bins_3d,)*3, range=[(-max_q, max_q)]*3, statistic='sum')
III = III/IIIc - np.mean(I_avg/n_patterns)**2
c = np.floor(n_bins_3d/2)
min_ = np.min(III[np.isfinite(III)])
III[~np.isfinite(III)] = min_
III[c,c,c] = min_

if qtview:
    print('Displaying results...')

    im = pg.image(np.transpose(III, axes=(1, 0, 2)))
    im.setCurrentIndex(np.floor(n_bins_3d/2))

    qa = pg.mkQApp()
    face_colors = np.ones([n_faces, 4])
    for i in range(0,3): face_colors[:, i] = (I / np.max(I))*0.9 + 0.1
    vw = gl.GLViewWidget()
    vw.show()
    md = gl.MeshData(vertexes=verts, faces=faces, faceColors=face_colors)
    mi = gl.GLMeshItem(meshdata=md, smooth=False) #, edgeColor=np.array([0.1, 0.1, 0.1])*255, drawEdges=True)
    vw.addItem(mi)
    qa.exec_()

# glw = pg.GraphicsLayoutWidget()
# glw.addItem(vw)



# if spherical_detector:
#     fig = plt.figure()
#     ax = fig.add_subplot(111, projection='3d')
#     mesh = Poly3DCollection(verts[faces], facecolors=mpl.cm.gray(I_noisy / np.max(I_noisy)), alpha=1, linewidths=0)
#     ax.add_collection3d(mesh, )
#     ax.scatter(fcs[:, 0], fcs[:, 1], fcs[:, 2], c='g', s=0, lw=0, alpha=0)
#     ax.set_aspect('equal', adjustable='box')
#     plt.show()
# else:
#     imdisp = I_noisy.reshape(pad.shape())
#     plt.imshow(np.log10(imdisp + 1), interpolation='nearest', cmap='gray')
#     plt.show()


    # plt.figure().add_subplot(111, projection='3d').scatter(v[:,0], v[:,1], v[:,2])
    # plt.figure().add_subplot(111, projection='3d').plot_surface(v[:,0], v[:,1], v[:,2])
    # plt.show()


    # Questions:
    # How does SNR scale with number of molecules?
    # How many shots needed?
