import numpy as np
import numba





def trilinear_interpolation(a_map, q, a_out)

    global dsfloat2 *a_map,  // Lookup table generated by phase_factor_mesh
    global dsfloat *q,       // Scattering vectors
    global dsfloat2 *a_out,  // The summed scattering amplitudes (output)
    int n_pixels,            // Number of pixels
    int4 N,                  // See phase_factor_mesh
    dsfloat4 deltaQ,         // See phase_factor_mesh
    dsfloat4 q_min,          // See phase_factor_mesh
    const dsfloat16 R        // Rotation matrix
){

    const int gi = get_global_id(0);

    dsfloat4 q4r = (dsfloat4)(q[gi*3],q[gi*3+1],q[gi*3+2],0.0f);
    q4r = rotate_vec(R,q4r);

    // Floating point coordinates
    const dsfloat i_f = (q4r.x - q_min.x)/deltaQ.x;
    const dsfloat j_f = (q4r.y - q_min.y)/deltaQ.y;
    const dsfloat k_f = (q4r.z - q_min.z)/deltaQ.z;

    // Integer coordinates
    const int i = (int)(floor(i_f));
    const int j = (int)(floor(j_f));
    const int k = (int)(floor(k_f));

    // Trilinear interpolation formula specified in
    //     paulbourke.net/miscellaneous/interpolation
    const int k0 = k*N.x*N.y;
    const int j0 = j*N.x;
    const int i0 = i;
    const int k1 = (k+1)*N.x*N.y;
    const int j1 = (j+1)*N.x;
    const int i1 = i+1;
    const dsfloat x0 = i_f - floor(i_f);
    const dsfloat y0 = j_f - floor(j_f);
    const dsfloat z0 = k_f - floor(k_f);
    const dsfloat x1 = 1.0f - x0;
    const dsfloat y1 = 1.0f - y0;
    const dsfloat z1 = 1.0f - z0;

    if (i >= 0 && i < N.x && j >= 0 && j < N.y && k >= 0 && k < N.z){

        a_out[gi] = a_map[i0 + j0 + k0] * x1 * y1 * z1 +

                    a_map[i1 + j0 + k0] * x0 * y1 * z1 +
                    a_map[i0 + j1 + k0] * x1 * y0 * z1 +
                    a_map[i0 + j0 + k1] * x1 * y1 * z0 +

                    a_map[i1 + j0 + k1] * x0 * y1 * z0 +
                    a_map[i0 + j1 + k1] * x1 * y0 * z0 +
                    a_map[i1 + j1 + k0] * x0 * y0 * z1 +

                    a_map[i1 + j1 + k1] * x0 * y0 * z0   ;

    } else {
        a_out[gi] = (dsfloat2)(0.0f,0.0f);
    }

}