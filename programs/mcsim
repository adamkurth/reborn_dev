#!/usr/bin/env python

import os
import sys
import time
import numpy as np
import configargparse
import h5py
from glob import glob
from scipy.special import erf

sys.path.append("..")  # This path setting won't be needed once bornagain is properly installed
import bornagain as ba
from bornagain.simulate import solutions
from bornagain.simulate import simutils
from bornagain.utils import vec_mag
from bornagain.units import r_e, hc, keV
import bornagain.simulate.clcore as core


########################################################################################################################
# Command-line input.  Most defaults are set here, but are subject to change (so do not rely on them).
########################################################################################################################

p = configargparse.ArgParser("""
Monte Carlo simulations of crystal diffraction on a GPU.
A more elaborate description of this program will follow...
""")
a = p.add

a('--config', is_config_file=True,
  help='Config file path, absolute path not relative path')

a('--pdb_file', type=str, nargs=1, default='../examples/data/pdb/2LYZ-P1.pdb',
  help='PDB file (symmetry is **not** expanded)')

a('--shape_transform', type=str, nargs=1, default='gaussian',
  help='Crystal shape transform model.  Options are parallelepiped or gaussian.')

a('--iterations', type=int, nargs=1, default=1000,
  help='Number of independent Monte Carlo iterations to average')

a('--double_precision', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Use double precision if device allows.')

a('--write_geom', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Write a crystfel geometry file.')

a('--write_hdf5', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Write data to hdf5 files.')

a('--mplview', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='View the pattern with matplotlib.')

a('--qtview', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='View the pattern with pyqtgraph.')

a('--skview', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='View the pattern with skimage viewer.')

a('--quiet', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Decreases printed output.')

a('--add_noise', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Adds Poisson noise to the image.')

a('--cromer_mann', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Cromer Mann')

a('--wigner', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='Overlay wigner cells')

a('--no_rotation', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=True,
  help='Removes random rotation of the crystal')

a('--fix-rotation-sequence', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1,
  help='Fixes the sequence of random orientation matrices so that mcsim can be run several times under different conditions, maintaining the same set of matrices throughout')

a('--no_beam_mask', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=True,
  help='Stops direct beam masking')

a('--no_monte_carlo',type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=True,
  help='Stops Monte Carlo simulation')

a('--beam_diameter', type=float, nargs=1, default=100e-6,
  help='Beam diameter')

a('--beam_divergence', type=float, nargs=1, default=0.010,
  help = 'Changes the beam divergence, input in radians')

a('--detector_distance', type=float, nargs=1, default=100e-3,
  help='Distance to the detector')

a('--pixel_size', type=float, nargs=1, default = 110e-6,
  help='Size of the pixels')

a('--photon_energy', type=float, nargs=1, default=12.0,
  help='Photon energy in keV')

a('--wavelength_fwhm', type=float, nargs=1, default=0.02,
  help='Spectral dispersion full-width, half-max value (dlambda/lambda)')

a('--photon_energy_fwhm', type=float, nargs=1, default=-1,
  help='Photon energy bandwidth full-width, half-max value (dE/E).')

a('--n_pixels', type=float, nargs=1, default=1000,
  help='Number of pixels')

a('--transmission', type=float, nargs=1, default=1.0,
  help='Transmission coefficient')

a('--n_photons', type=float, nargs=1, default=1e8,
  help='Number of photons')

a('--mosaic_domain_size', type=float, nargs=1, default=1000e-9,
  help='Mosaic domain size')

a('--mosaicity_fwhm', type=float, nargs=1, default=0.0001,
  help='Mosaicity full-width, half-max value')

a('--results_dir', type=str, nargs=1, default='/data/temp/cxls-lysozyme-02/',
  help='Directory where the results are saved')

a('--num_patterns', type=int, nargs=1, default=1,
  help='Number of patterns to simulate')

a('--crystal_size', type=float, nargs=1, default=0.0,
  help='Size of crystal in meters (default is beam diameter)')

a('--water', type=bool, nargs=1, default=False,
  help='Whether to do water scattering or not. If true, --water_radius must also be specified.')

a('--water_radius', type=float, nargs=1, default=0.0,
  help='Radius of water jet in meters without crystal in it. Must be large enough to fully envelop crystal.')

a('--temperature', type=float, nargs=1, default=298.16,
  help='Temperature of water jet in Kelvin. Default is 298.16 K.')

a('--flux', type=float, nargs=1, default=0,
  help='Flux of icident beam in photons/s. Must also specify exposure. Replaces n_photons.')

a('--exposure', type=float, nargs=1, default=0,
  help='Exposure time in seconds. Must also specify flux. Replaces n_photons.')

a('--beam_spatial_profile', type=str, nargs=1, default='tophat',
  help='Gaussian or tophat photon density for beam. If Gaussian, beam_diameter is assumed to be 3 sigmas.')

a('--compression', type=str, nargs=1, default=None,
  help='h5py compression, default None, can be lzf or gzip')

a('--ideal_only', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='only store the ideal scattering in output (not the noisy scattering)')

a('--expand_symmetry', type=lambda s: s.lower() in ['true', 't', 'yes', '1'], nargs=1, default=False,
  help='expand the PDB coordinates according to crystal symmetry operators')

a = p.parse_args()


########################################################################################################################
# Now do something intelligent with the input.  Basic sanity checks, etc.
########################################################################################################################

def get_arg(arg):
    # Annoyingly, I can't seem to predict if parse_args() members will be list objects; this function checks for that
    # and returns the first list item as appropriate
    if isinstance(arg, (list, tuple)): return arg[0]
    return arg

# This needs to be thought through more carefully.  E.g. check if pdb file exists, send message if it doesn't, and so
# on.
pdb_file                        = get_arg(a.pdb_file)
n_monte_carlo_iterations        = get_arg(a.iterations)
shape_transform_model           = get_arg(a.shape_transform)
write_hdf5                      = get_arg(a.write_hdf5)
print(write_hdf5)
write_geom                      = get_arg(a.write_geom)
mplview                         = get_arg(a.mplview)
qtview                          = get_arg(a.qtview)
skview                          = get_arg(a.skview)
quiet                           = get_arg(a.quiet)
cromer_mann                     = get_arg(a.cromer_mann)
random_rotation                 = get_arg(a.no_rotation)
beam_diameter                   = get_arg(a.beam_diameter)
detector_distance               = get_arg(a.detector_distance)
pixel_size                      = get_arg(a.pixel_size)
add_noise                       = get_arg(a.add_noise)
photon_energy                   = get_arg(a.photon_energy) / keV
n_pixels                        = get_arg(a.n_pixels)
transmission                    = get_arg(a.transmission)
n_photons                       = int(get_arg(a.n_photons)) # pulse_energy / photon energy # 1e12
mosaic_domain_size              = get_arg(a.mosaic_domain_size)
mosaicity_fwhm                  = get_arg(a.mosaicity_fwhm)
overlay_wigner_cells            = get_arg(a.wigner)
results_dir                     = get_arg(a.results_dir)
mask_direct_beam                = get_arg(a.no_beam_mask)
approximate_shape_transform     = get_arg(a.shape_transform)
do_monte_carlo                  = get_arg(a.no_monte_carlo) # This should not be needed; set bandwidth etc. to zero of you don't want monte carlo...
beam_divergence_fwhm            = get_arg(a.beam_divergence) * (8e-6 / beam_diameter)
num_patterns                    = get_arg(a.num_patterns)
water                           = get_arg(a.water)
water_radius                    = get_arg(a.water_radius)
temperature                     = get_arg(a.temperature)
flux                            = get_arg(a.flux)
exposure                        = get_arg(a.exposure)
beam_spatial_profile            = get_arg(a.beam_spatial_profile)
photon_energy_fwhm              = get_arg(a.photon_energy_fwhm)
wavelength                      = hc / photon_energy # pulse_energy = 0.0024
if photon_energy_fwhm != -1:
    wavelength_fwhm = (wavelength**2 * photon_energy_fwhm * photon_energy) / float(hc)
else:
    wavelength_fwhm                 = wavelength * get_arg(a.wavelength_fwhm)
crystal_size                    = get_arg(a.crystal_size)
if crystal_size == 0:
    crystal_size = beam_diameter
if(flux != 0):
    n_photons = flux*exposure # Get number of photons from beam parameters
I0                              = transmission * n_photons / (beam_diameter ** 2) # Square beam
rotation_axis                   = [1, 0, 0]
rotation_angle                  = 0.1
compression =get_arg(a.compression)
write_ideal_only = get_arg(a.ideal_only)
expand_symm = get_arg( a.expand_symmetry)
fix_rot_seq = get_arg(a.fix_rotation_sequence)

#parameters                      = get_arg(a.parameters)
#no_params                       = get_arg(a.no_params)

# Creating text file with output parameters
values = [pdb_file, crystal_size, photon_energy*keV, flux, exposure, n_photons, n_monte_carlo_iterations, shape_transform_model,
          write_hdf5, write_geom, mplview, qtview, skview, quiet, cromer_mann, random_rotation, beam_diameter, beam_spatial_profile,
          detector_distance, pixel_size, add_noise, int(n_pixels), transmission, mosaic_domain_size, mosaicity_fwhm,
          overlay_wigner_cells, results_dir, mask_direct_beam, do_monte_carlo,
          beam_divergence_fwhm/(8e-6/beam_diameter), num_patterns, water, water_radius, temperature, wavelength]

names = ['pdb_file', 'crystal_size', 'photon_energy', 'flux', 'exposure', 'n_photons', 'iterations', 'shape_transform',
          'write_hdf5', 'write_geom', 'mplview', 'qtview', 'skview', 'quiet', 'cromer_mann', 'no_rotation', 'beam_diameter', 'beam_spatial_profile',
          'detector_distance', 'pixel_size', 'add_noise', 'n_pixels', 'transmission', 'mosaic_domain_size', 'mosaicity_fwhm',
          'wigner', 'results_dir', 'no_beam_mask', 'no_monte_carlo',
          'beam_divergence', 'num_patterns', 'water', 'water_radius', 'temperature', 'wavelength']

pseudo_dict = zip(names, values)
dictionary  = dict(pseudo_dict)
if photon_energy_fwhm != -1:
    dictionary['photon_energy_fwhm']=photon_energy_fwhm
else:
    dictionary['wavelength_fwhm']=wavelength_fwhm/wavelength
file_name = results_dir + 'used_params.txt'
used_params = open(str(file_name), 'w+')
for k, v in dictionary.items():
    if v != str(v):
        v = str(v)
    used_params.write(k + '=' + v + '\n')

if not os.path.exists(results_dir):
    os.makedirs(results_dir)

# Doesn't make sense if mosaic domain size is larger than the whole crystal...
if mosaic_domain_size > crystal_size: mosaic_domain_size = crystal_size

if not do_monte_carlo:
    n_monte_carlo_iterations = 1

if not quiet:
    write = sys.stdout.write
else:
    write = lambda x: x

section = '=' * 70 + '\n'

write(section)
if fix_rot_seq:
    write("Fixing the rotation sequence based on random seed")
write('PDB file: %s\n' % (os.path.basename(pdb_file)))
write('Photons per pulse: %g\n' % (n_photons))
write('Photon energy: %g keV\n' % (photon_energy * keV))
write('Beam divergence: %g mrad FWHM\n' % (beam_divergence_fwhm * 1e3))
write('Beam diameter: %g microns tophat\n' % (beam_diameter * 1e6))
write('Spectral width: %g%% FWHM dlambda/lambda\n' % (100 * wavelength_fwhm / wavelength))
write('Crystal size: %g microns\n' % (crystal_size * 1e6))
write('Crystal mosaicity: %g radian FWHM\n' % (mosaicity_fwhm))
write('Crystal mosaic domain size: %g microns\n' % (mosaic_domain_size * 1e6))
write(section)

# Things we probably don't want to think about
cl_group_size = 32
cl_double_precision = False

# Don't import nasty viewer libraries unless needed...:
if mplview:
    import matplotlib.pyplot as plt
if qtview:
    import pyqtgraph as pg
    pg.setConfigOptions(antialias=True)
if skview:
    from skimage.viewer import ImageViewer

if a.double_precision:
    cl_double_precision = True

if shape_transform_model == 'gaussian':
    approximate_shape_transform = True
elif shape_transform_model == 'parallelepiped':
    approximate_shape_transform = False
else:
    sys.stderr.write('Crystal shape transform model not recognized: %s\n' % (shape_transform_model))
    sys.stderr.write('The options are: gaussian or parallelepiped\n')
    sys.exit(1)


# Setup simulation engine
write('Setting up simulation engine... ')
clcore = core.ClCore(group_size=cl_group_size, double_precision=cl_double_precision)
write('done\n')

write('Will run %d Monte Carlo iterations\n' % (n_monte_carlo_iterations))

# Setup source info
beam_vec = np.array([0,0,1])
polarization_vec = np.array([1,0,0])
polarization_weight = 1.0 # Fraction of polarization in this vector

# Setup detector geometry
write('Configuring detector... ')
pad = ba.detector.PADGeometry()
pad.simple_setup(n_pixels=n_pixels, pixel_size=pixel_size, distance=detector_distance)
q = pad.q_vecs(beam_vec=beam_vec, wavelength=wavelength)
qmag = vec_mag(q)
sa = pad.solid_angles()
P = pad.polarization_factors(polarization_vec=polarization_vec,beam_vec=beam_vec,weight=polarization_weight)
write('done\n')

# Do water scattering
if(water):
    write('Simulating water scattering... ')
    water_number_density = 33.3679e27
    illuminated_water_volume = simutils.volume_solvent(beam_diameter, crystal_size, water_radius)
    n_water_molecules = illuminated_water_volume * water_number_density
    F_water = solutions.get_water_profile(qmag, temperature=temperature) # Get water scattering intensity radial profile
    F2_water = F_water**2 * n_water_molecules
    I_water = I0 * r_e**2 * P * sa * F2_water
    if(illuminated_water_volume <= 0):
        write('\nWarning: No solvent was illuminated, water scattering not performed.\n')
        water = False
        I_water = 0
    else:
        write('done\n')

# Get atomic coordinates and scattering factors from pdb file
write('Getting atomic coordinates and scattering factors... ')
if expand_symm:
    cryst = ba.target.crystal.Molecule(pdb_file)
    monomers = cryst.get_monomers()
    all_atoms = ba.target.crystal.Atoms.aggregate(monomers)
    r = all_atoms.xyz*1e-10
    Z = all_atoms.Z
else:
    cryst = ba.target.crystal.structure(pdb_file)
    r = cryst.r
    Z = cryst.Z

f = ba.simulate.atoms.get_scattering_factors(Z, ba.units.hc / wavelength)
write('done\n')
write('%d atoms per unit cell\n' % (len(f)))

# Make a mask for the direct beam

direct_beam_mask = np.ones((int(pad.n_ss * pad.n_fs)))
direct_beam_mask[qmag < (2 * np.pi / np.max(np.array([cryst.a, cryst.b, cryst.c])))] = 0

# Determine number of unit cells in whole crystal and mosaic domains
n_cells_whole_crystal = np.ceil(crystal_size / np.array([cryst.a, cryst.b, cryst.c]))
n_cells_mosaic_domain = np.ceil(mosaic_domain_size / np.array([cryst.a, cryst.b, cryst.c]))
if(crystal_size > beam_diameter):
    n_cells_whole_crystal = np.ceil(np.array([beam_diameter, beam_diameter, crystal_size]) / np.array([cryst.a, cryst.b, cryst.c]))
if(mosaic_domain_size > beam_diameter):
    n_cells_mosaic_domain = np.ceil(np.array([beam_diameter, beam_diameter, mosaic_domain_size]) / np.array([cryst.a, cryst.b, cryst.c]))

# Setup function for shape transform calculations
if approximate_shape_transform:
    write('Using approximate (Gaussian) shape transform\n')
    shape_transform = clcore.gaussian_lattice_transform_intensities_pad
else:
    write('Using idealized (parallelepiped) shape transform\n')
    shape_transform = clcore.lattice_transform_intensities_pad

if write_geom:
    geom_file = results_dir + 'geom.geom'
    write('Writing geometry file %s\n' % geom_file)
    fid = open(geom_file, 'w')
    fid.write("photon_energy = %g\n" % (photon_energy * ba.units.eV))
    fid.write("clen = %g\n" % detector_distance)
    fid.write("res = %g\n" % (1 / pixel_size))
    fid.write("adu_per_eV = %g\n" % (1.0 / (photon_energy * ba.units.eV)))
    fid.write("0/min_ss = 0\n")
    fid.write("0/max_ss = %d\n" % (n_pixels - 1))
    fid.write("0/min_fs = 0\n")
    fid.write("0/max_fs = %d\n" % (n_pixels - 1))
    fid.write("0/corner_x = %g\n" % (-n_pixels / 2.0))
    fid.write("0/corner_y = %g\n" % (-n_pixels / 2.0))
    fid.write("0/fs = x\n")
    fid.write("0/ss = y\n")
    fid.close()


# Allocate memory on GPU device
write('Allocating GPU device memory... ')
r_dev = clcore.to_device(r, dtype=clcore.real_t)
f_dev = clcore.to_device(f, dtype=clcore.complex_t)
F_dev = clcore.to_device(np.zeros([int(pad.n_ss * pad.n_fs)], dtype=clcore.complex_t))
S2_dev = clcore.to_device(shape=(int(pad.n_fs), int(pad.n_ss)), dtype=clcore.real_t)
write('done\n')

for i in np.arange(1, (num_patterns + 1)):
    R = ba.utils.rotation_about_axis(rotation_angle, rotation_axis)
    if random_rotation: R = ba.utils.random_rotation()

    if random_rotation:
        if fix_rot_seq:
            np.random.seed(i)
        R = ba.utils.random_rotation()
    if not cromer_mann:
        write('Simulating molecular transform from Henke tables... ')
        t = time.time()
        clcore.phase_factor_pad(r_dev, f_dev, pad.t_vec, pad.fs_vec,
            pad.ss_vec, beam_vec, pad.n_fs, pad.n_ss, wavelength, R, F_dev, add=False)
        F2 = np.abs(F_dev.get()) ** 2
        tf = time.time() - t
        write('%g s\n' % (tf))
    else:
        write('Simulating molecular transform with cromer mann... ')
        t = time.time()
        clcore.prime_cromermann_simulator(q.copy(), Z.copy())
        #clcore.prime_cromermann_simulator(q.copy(), cryst.Z.copy())
        q_cm = clcore.get_q_cromermann()
        r_cm = clcore.get_r_cromermann(r.copy(), sub_com=False)
        clcore.run_cromermann(q_cm, r_cm, rand_rot=False, force_rot_mat=R)
        A = clcore.release_amplitudes(reset=True)
        F2 = np.abs(A) ** 2
        tf = time.time() - t
        write('%g s\n' % (tf))

    abc = cryst.O.T.copy()
    S2_dev *= 0

    write('Simulating shape transform... ')
    time.sleep(0.001)
    message = ''
    tt = time.time()
    for n in np.arange(1, (n_monte_carlo_iterations + 1)):

        t = time.time()
        if do_monte_carlo:
            B = ba.utils.random_beam_vector(beam_divergence_fwhm)
            if (wavelength_fwhm == 0):
                w = wavelength
            else:
                w = np.random.normal(wavelength, wavelength_fwhm / 2.354820045, [1])[0]
            Rm = ba.utils.random_mosaic_rotation(mosaicity_fwhm).dot(R)
            T = pad.t_vec.copy() + pad.fs_vec * (np.random.random([1]) - 0.5) + pad.ss_vec * (np.random.random([1]) - 0.5)
        else:
            B = beam_vec
            w = wavelength
            Rm = R
            T = pad.t_vec

        shape_transform(abc, n_cells_mosaic_domain, T, pad.fs_vec, pad.ss_vec, B, pad.n_fs, pad.n_ss, w, Rm, S2_dev, add=True)

        tf = time.time() - t
        if (n % 1000) == 0:
            write('\b' * len(message))
            message = '%3.0f%% (%5d; %7.03f ms)' % (n / float(n_monte_carlo_iterations) * 100, n, tf * 1e3)
            write(message)
    write('\b' * len(message))
    write('%g s                \n' % (time.time() - tt))

    # Average the shape transforms over MC iterations
    S2 = S2_dev.get().ravel() / n
    # Convert into useful photon units
    I = I0 * r_e ** 2 * F2 * S2 *  sa * P 
    if(crystal_size < beam_diameter): # Correct for lower incident intensity
        if(beam_spatial_profile == 'gaussian'): # Approximate square beam+crystal as circular with same areas and multiply intensity by area under a radial Gaussian distribution
            sig = beam_diameter / 3.0 # Let beam_diameter be 3 sigmas
            I *= erf(crystal_size/(sig * np.sqrt(2)))
        elif(beam_spatial_profile == 'tophat'):
            I *= (crystal_size/beam_diameter)**2
        else:
            sys.stderr.write('Beam spatial profile not recognized: %s\n' % (beam_spatial_profile))
            sys.stderr.write('The options are: tophat or gaussian\n')
            sys.exit(1)

    # Scale up according to mosaic domain
    n_domains = np.prod(n_cells_whole_crystal) / np.prod(n_cells_mosaic_domain)
    I_ideal = I.copy() * n_domains
    if(water):
        I_ideal += I_water
    I_ideal = I_ideal.astype(np.float32)
    I_noisy = np.random.poisson(I_ideal).astype(np.float32)

    if write_hdf5:
        n_patterns = len(glob( os.path.join(results_dir , 'pattern-*.h5')))
        file_name = os.path.join( results_dir , 'pattern-%06d.h5' % (n_patterns + 1))
        write('Writing file %s\n' % file_name)
        fid = h5py.File(file_name, 'w')
        fid['/data/ideal'] = I_ideal.astype(np.float32).reshape((pad.n_ss, pad.n_fs))
        fid['/data/noisy'] = I_noisy.astype(np.int32).reshape((pad.n_ss, pad.n_fs))
        fid.close()

        with h5py.File( file_name,  'w') as fid:
            sh = (int(pad.n_ss), int(pad.n_fs))
            fid.create_dataset("data/ideal",
                data= I_ideal.astype(np.float32).reshape(sh),
                compression=compression, shape=sh)
            #if not write_ideal_only:
            #    fid.create_dataset("data/noisy",
            #        data= I_noisy.astype(np.float32).reshape(sh),
            #        compression=compression, shape=sh)
            fid.create_dataset("rotation_matrix", data=R)

    F2mean = np.mean(F2.flat[direct_beam_mask > 0])
    Ncells = np.prod(n_cells_whole_crystal)
    darwin = I0 * r_e ** 2 * Ncells * F2mean * (wavelength ** 3 / cryst.V)

# End of pattern loop

write("\n\nDone!\n\n")

# The following is just for display purposes:
# Most likely the display settings are wrong... difficult to guess at this...
if qtview or mplview or skview:

    if add_noise:
        write('Displaying with noise\n')
        I_display = I_noisy.copy()
    else:
        write('Displaying **without** noise\n')
        I_display = I_ideal.copy()

    if overlay_wigner_cells:
        hkl = cryst.O.dot(R).dot(q.T) / 2.0 / np.pi  # .dot(cryst.Oinv)
        delta = hkl - np.round(hkl)
        delta = npad.ss_vecqrt(npad.ss_vecum(delta ** 2, axis=0))
        peak_mask = np.zeros((pad.n_fs * pad.n_ss))
        peak_mask[delta < 0.5] = 1
        I_display += peak_mask * 1e-2

    if mask_direct_beam:
        write('Masking direct beam\n')
        I_display *= direct_beam_mask

    write('Taking log10 of simulated intensities\n')
    I_display = np.log10(I_display + 1e-20)
    I_display = I_display.reshape((pad.n_ss, pad.n_fs))

    if qtview:
        img = pg.image(I_display, autoLevels=False, levels=[-0.4, np.log10(10)],
                       title='log10(I); %.1f micron; %.2f mrad; %.1f%% BW; ' %
                             (beam_diameter * 1e6, beam_divergence_fwhm * 1000, wavelength_fwhm / wavelength * 100))
        if __name__ == '__main__':
            if sys.flags.interactive != 1 or not hasattr(QtCore, 'PYQT_VERSION'):
                pg.QtGui.QApplication.exec_()
    elif skview:
        viewer = ImageViewer(I_display)
        viewer.show()
    elif mplview:
        plt.imshow(I_display, interpolation='nearest', cmap='gray', origin='lower')
        plt.show()
