

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta name="robots" content="noindex, nofollow" />
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Simulations &mdash; bornagain 0.2018.9.9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Notes for Developers" href="coding.html" />
    <link rel="prev" title="Detectors" href="geometry.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> bornagain
          

          
          </a>

          
            
            
              <div class="version">
                0.2018.9.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="beams.html">Beams</a></li>
<li class="toctree-l1"><a class="reference internal" href="targets.html">Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="geometry.html">Detectors</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="coding.html">Notes for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy.html">Numpy, vectors, rotations, etc.</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">bornagain</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bornagain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Simulations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/simulations.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simulations">
<h1>Simulations<a class="headerlink" href="#simulations" title="Permalink to this headline">¶</a></h1>
<p>TODO: Document the simulation code…</p>
<p>Currently, all GPU simulation utilities in bornagain utilize the pyopencl package.  You can check if opencl is installed correctly
and find specific information about available compute devices with the <a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.help" title="bornagain.simulate.clcore.help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> function.
In principle, the pyopencl package also allows the use of CPU computing, but
none of the code has been written with that in mind thus far.  If it is needed
we can explore that option.</p>
<p>The basic simulation functions are accessed by creating an instance of the
<a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> class.  This class is meant to do some of the following</p>
<ul class="simple">
<li>maintain an opencl context and queue</li>
<li>manage the compute group size</li>
<li>manage the precision (double/single)</li>
<li>make it easy for you to move data between GPU memory and RAM (using the context and queue)</li>
</ul>
<p>The above model seems to work well when using a single GPU device, but note that it has not been designed to
make use of multiple GPU devices (this might be easy to do, but we’ve not had a need thus far).</p>
<p>Aside from taking care of some low-level management of how the GPU device is used, the
<a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> class is primarily meant to provide only the most basic building blocks for
simulations, in the form of simple functions.  <a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> it is not meant to
manage data arrays; it is the lowest-level class
in the simulate package, and the basic idea is that you should make a specialized subclass for any specialized memory management.
(At the moment, there are some methods within <a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> that manage data arrays,
but they will be depreciated and moved to subclasses soon.)</p>
<p>Most of the method available through the <a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> class are
dedicated to computing the sum</p>
<blockquote>
<div><span class="math notranslate nohighlight">\(F(\vec{q}) = \sum_n f_n(q)e^{i\vec{q}\cdot\vec{r}_n}\)</span></div></blockquote>
<p>There are a couple of variations on how you can do this basic computation.  The most flexible way to compute the sum is to provide the
array of <span class="math notranslate nohighlight">\(\vec{q}\)</span> vectors as an input to the function, in which case you obviously get to choose how those
vectors are defined.  There are two other options that might help improve speed: one variant computes the
<span class="math notranslate nohighlight">\(\vec{q}\)</span> vectors corresponding to a PAD on the GPU
rather than getting them from global memory, and another variant computes the <span class="math notranslate nohighlight">\(\vec{q}\)</span> vectors on a regular 3D
grid.  In the case that you compute <span class="math notranslate nohighlight">\(F(\vec{q})\)</span> on a 3D grid, there is a corresponding function that can perform
interpolations such that you can sample <span class="math notranslate nohighlight">\(F(\vec{q})\)</span> at any <span class="math notranslate nohighlight">\(\vec{q}\)</span> that lies within the grid.</p>
<p>The methods in <a class="reference internal" href="bornagain.simulate.clcore.html#bornagain.simulate.clcore.ClCore" title="bornagain.simulate.clcore.ClCore"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClCore</span></code></a> allow you to pass in CPU arrays and retrieve CPU
arrays in return.
That is the simplest way to to GPU compuations since you can just use the methods without ever
thinking about memory.  However, the bottleneck in GPU computations is often due to moving memory between devices.
You can reduce computation time by copying/creating some or all of your arrays to the GPU device
ahead of the function call.  Likewise, you can retrieve the output in the form of pyopencl Array objects, which contain your data in GPU memory.  This alternative is especially useful if you plan to use the same array of <span class="math notranslate nohighlight">\(\vec{q}\)</span>
vectors many times over - you obviously don’t want to move your vectors between CPU and GPU many times over.
Moving a numpy array to the GPU device is easy with the <code class="xref py py-func docutils literal notranslate"><span class="pre">to_device()</span></code> method, which is just a wrapper for the equivalent in the pyopencl package.  You can easily move the data from the GPU to the CPU with the <code class="xref py py-func docutils literal notranslate"><span class="pre">get()</span></code> method (this is just a built-in method of the pyopencl Array class).</p>
<p>At a much higher level, there is a Monte Carlo simulator that generates crystal diffraction patterns.  This will be
documented by Rick and Cameron some day.  The basic idea is that we have an engine that serves up diffraction intensities
in a Monte Carlo fashion, by jittering the incident beam direction, pixel positions, crystal orientations, and so on.</p>
<p>Other simulation engines might be built soon.  For example, an engine for solution scattering will come along soon.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="coding.html" class="btn btn-neutral float-right" title="Notes for Developers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="geometry.html" class="btn btn-neutral" title="Detectors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>